git clone https://github.com/mapbox/earcut.hpp
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
git log -n 10 > mapbox-earcut.hpp.git.log
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
git log -n 10 } mapbox-earcut.hpp.git.log
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
git log -n 10 | mapbox-earcut.hpp.git.log
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
git log -n 10>| mapbox-earcut.hpp.git.log
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
git log >  mapbox-earcut.hpp.git.log
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
cd earcut.hpp
git log -n 20  >  ../mapbox-earcut.hpp.git.log
")
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
cd earcut.hpp
git log -n 5  >  ../mapbox-earcut.hpp.git.log
")
usethis::use_readme_rmd()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
tools::package_native_routine_registration_skeleton("../rearcut", "src/init.c",character_only = FALSE)
library(rearcut)
system("
cd data-raw
#git clone https://github.com/mapbox/earcut.hpp
cp earcut.hpp/include/mapbox/earcut.hpp ../src/
cp earcut.hpp/LICENSE ../src/
cd earcut.hpp
git log -n 5  >  ../mapbox-earcut.hpp.git.log
")
library(rearcut)
library(rearcut)
library(rearcut)
rearcut(1, 1)
library(rearcut)
rearcut(1, 1)
library(rearcut)
rearcut(1:10, 10:1)
Rcpp::sourceCpp('src/rearcut.cpp')
library(silicate)
minimal_mesh$geom[[1]]
minimal_mesh$geom[[1]][[1]]
minimal_mesh$geom[[1]][[1]][[1]]
dput(minimal_mesh$geom[[1]][[1]][[1]])
library(rearcut)
library(rearcut)
rearcut(1:10, 10:1)
library(rearcut)
library(rearcut)
X <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69, 0)
Y <- c(0, 1, 1, 0.8, 0.7, 0.6, 0, 0)
rgl::triangulate(X, Y)
dput(rgl::triangulate(X, Y))
X <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69, 0)
Y <- c(0, 1, 1, 0.8, 0.7, 0.6, 0, 0)
ind <- rearcut(X, Y)  ## should be longer than 0 :)
## a working case for illustration
if (length(ind) < 3) {
ind <- c(8L, 2L, 1L, 8L, 5L, 2L, 8L, 7L, 5L, 5L, 3L, 2L, 5L,
4L, 3L, 7L, 6L, 5L) - 1
}
plot(X, Y)
apply(matrix(ind, nrow = 3), 2, function(x) polygon(cbind(X, Y)[x + 1, ]))
library(rearcut)
library(rearcut)
X <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69, 0)
Y <- c(0, 1, 1, 0.8, 0.7, 0.6, 0, 0)
ind <- rearcut(X, Y)  ## should be longer than 0 :)
if (length(ind) < 3) {
// this is rgl's solution, it's not necessarily deterministic
ind <- c(8L, 2L, 1L, 8L, 5L, 2L, 8L, 7L, 5L, 5L, 3L, 2L, 5L,
4L, 3L, 7L, 6L, 5L) - 1
}
plot(X, Y)
X <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69, 0)
Y <- c(0, 1, 1, 0.8, 0.7, 0.6, 0, 0)
ind <- rearcut(X, Y)  ## should be longer than 0 :)
if (length(ind) < 3) {
## this is rgl's solution, it's not necessarily deterministic
ind <- c(8L, 2L, 1L, 8L, 5L, 2L, 8L, 7L, 5L, 5L, 3L, 2L, 5L,
4L, 3L, 7L, 6L, 5L) - 1
}
plot(X, Y)
apply(matrix(ind, nrow = 3), 2, function(x) polygon(cbind(X, Y)[x + 1, ]))
library(rearcut)
library(rearcut)
P_d(1, 1)
library(rearcut)
P_d(1, 1)
library(rearcut)
library(rearcut)
P_d(1, 1)
library(rearcut)
P_d(1, 1)
library(rearcut)
P_d(1, 1)
P_d(1:10, 1:10)
library(rearcut)
P_d(1:10, 1:10)
library(rearcut)
P_d(1:10, 1:10)
library(rearcut)
X <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69, 0)
Y <- c(0, 1, 1, 0.8, 0.7, 0.6, 0, 0)
ind <- rearcut(X, Y)
ind
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
tools::package_native_routine_registration_skeleton("../rearcut", "src/init.c",character_only = FALSE)
library(rearcut)
ind <- rearcut(X, Y)
ind
library(rearcut)
ind <- rearcut(X, Y)
ind
P_d(X, Y)
rearcut(X, Y)
library(rearcut)
rearcut(X, Y)
library(rearcut)
rearcut(X, Y)
library(rearcut)
rearcut(X, Y)
P_d(X, Y)
library(rearcut)
devtools::load_all(".")
devtools::load_all(".")
library(rearcut)
library(rearcut)
library(rearcut)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
## example data from polypath
## rather than separate rings by NA we indicate those positions
## (here the hole starts at 5 and is the only one)
x <- c(.1, .1, .9, .9, .2, .2, .8, .8)
y <- c(.1, .9, .9, .1, .2, .8, .8, .2)
library(rearcut)
ind <- earcut(cbind(x, y), holes = 5L)
rearcut:::plot_tri(x, y, ind, col = "grey")
xy.coords(list(1, 2))
xy.coords(list(y = 1, x = 2))
xy.coords(data.frame(y = 1, x = 2))
xy.coords(cbind(1, 2))
xy.coords(cbind(y = 1, x = 2))
xy.coords(1, 2)
xy.coords(y = 1, x = 2)
xy.coords(a = 1, b = 2)
xy.coords(x = 2, y = 1)
xy.coords(c(x = 1, y = 2))
xy.coords(list(1, 2))
xy.coords(list(y = 1, x = 2))
xy.coords(data.frame(y = 1, x = 2))
xy.coords(cbind(y = 1, x = 2))
xy.coords(data.frame(y = 1, x = 2))
xy.coords(list(y = 1, x = 2))
plot(data.frame(y = 1, x = 2))
plot(cbind(y = 1, x = 2))
xy.coords(cbind(y = 1, x = 2))
silicate::sc_coord(minimal_mesh$geometry[1])
data("minimal_mesh", package = "silicate")
silicate::sc_coord(minimal_mesh$geometry[1])
silicate::sc_coord(minimal_mesh$geometry[[1]])
silicate::sc_coord(minimal_mesh$geom[[1]])
gmap <- silicate::sc_path(minimal_mesh$geom[[1]])
gmap
cumsum(gmap$nrow)
tail(cumsum(gmap$nrow), 1)
head(cumsum(gmap$nrow), 1)
hole_index <- head(cumsum(gmap$nrow), 1) + 1 ## only works for POLYGON analogues
hole_index
##
purrr::map(gmap$nrow, seq)
##
coords %>% split(purrr::map_int(gmap$nrow, seq))
##
library(dplyr)
coords %>% split(purrr::map_int(gmap$nrow, seq))
coords <- silicate::sc_coord(minimal_mesh$geom[[1]])
gmap <- silicate::sc_path(minimal_mesh$geom[[1]])
##
library(dplyr)
coords %>% split(purrr::map_int(gmap$nrow, seq))
purrr::map_int(gmap$nrow, seq)
purrr::map_int(gmap$nrow, seq)
purrr::map(gmap$nrow, seq)
purrr::map_intr(gmap$nrow, seq)
?purrr::map_dfr
purrr::map(1:2, seq)
purrr::map_int(1:2, seq)
purrr::map(1:2, seq)
purrr::map(1:2, seq) %>% flatten()
purrr::map(1:2, seq) %>% purrr::flatten()
purrr::map(1:2, seq) %>% purrr::flatten(.)
purrr::map(1:2, seq) %>% purrr::flatten_int(.)
coords %>% split(purrr::map(gmap$nrow, seq)) %>% purrr::flatten_int()
coords %>% split(purrr::map(gmap$nrow, seq)) %>% purrr::flatten_int(.)
coords %>% split(purrr::map(gmap$nrow, seq) %>% purrr::flatten_int(.))
gmap$nrow
purrr::map(gmap$nrow, seq) %>% purrr::flatten_int(.)
coords %>% split(purrr::map(gmap$nrow, rep) %>% purrr::flatten_int(.))
purrr::map(gmap$nrow, rep)
purrr::map(gmap$nrow, rep) %>% purrr::flatten_int(.)
split(1:10, 5)
split(1:10, c(5, 8))
split(1:10, 1:2)
split(1:100, 1:5)
rep(seq_along(gmap$nrow), each = gmap$nrow))
rep(seq_along(gmap$nrow), each = gmap$nrow)
rep(seq_along(gmap$nrow), gmap$nrow)
coords %>% split(rep(seq_along(gmap$nrow), gmap$nrow)))
coords %>% split(rep(seq_along(gmap$nrow), gmap$nrow))
head(1:10, -1)
##
rbind_na <- function(...) {
head(dplyr::bind_rows(purrr::map(list(...), ~rbind(.x, NA))), -1L)
}
coords %>%
split(rep(seq_along(gmap$nrow), gmap$nrow)) %>%
rbind_na()
##
rbind_na <- function(x) {
head(dplyr::bind_rows(purrr::map(x, ~rbind(.x, NA))), -1L)
}
coords %>%
split(rep(seq_along(gmap$nrow), gmap$nrow)) %>%
rbind_na()
minpoly <- coords %>%
split(rep(seq_along(gmap$nrow), gmap$nrow)) %>%
rbind_na()
plot(minpoly)
polypath(minpoly)
usethis::use_data(minpoly)
?minpoly
library(rearcut)
plot(minpoly)
polypath(minpoly, col = "grey)
polypath(minpoly, col = "grey")
plot(minpoly)
polypath(minpoly, col = "grey", rule = "evenodd")
lines(na.omit(minpoly))
minpoly
which(is.na(minpoly$x_))
nas <- which(is.na(minpoly$x_))
nas
hole_index <- nas - seq_along(nas)
hole_index
View(minpoly)
##------------------------------------------------
data("inlandwaters", package = "silicate")
which(inlandwaters$Province == "Tasmania")
inlandwaters$geom[which(inlandwaters$Province == "Tasmania")]
inlandwaters$geom[which(inlandwaters$Province == "Tasmania")][[1]]
taslakes <- inlandwaters$geom[which(inlandwaters$Province == "Tasmania")][[1]]
sc_coord(taslakes)
silicate::sc_coord(taslakes)
gmap <- silicate::sc_path(taslakes)
gmap
taslakes <- inlandwaters$geom[which(inlandwaters$Province == "Tasmania")][[2]]
coords <- silicate::sc_coord(taslakes)
taslakes <- inlandwaters$geom[which(inlandwaters$Province == "Tasmania")][[1]][2]
coords <- silicate::sc_coord(taslakes)
plot(coords)
str(coords)
tas <- sf::st_cast("inlandwaters", "POLYGON")
tas <- sf::st_cast(inlandwaters, "POLYGON")
taslakes <- subset(tas, Province == "Tasmania")[2, ]
coords <- silicate::sc_coord(taslakes)
plot(coords)
gmap <- silicate::sc_path(taslakes)
taslakes <- coords %>%
split(rep(seq_along(gmap$nrow), gmap$nrow)) %>%
rbind_na()
taslakes <- subset(tas, Province == "Tasmania")[2, ]
coords <- silicate::sc_coord(taslakes)
gmap <- silicate::sc_path(taslakes)
taslakes <- coords %>%
split(rep(seq_along(gmap$nrow), gmap$nrow)) %>%
rbind_na()
gmap
taslakes <- coords %>%
split(rep(seq_along(gmap$coords_), gmap$ncoords_)) %>%
rbind_na()
taslakes <- coords %>%
split(rep(seq_along(gmap$ncoords_), gmap$ncoords_)) %>%
rbind_na()
plot(taslakes)
plot(taslakes, pch = ".")
polypath(taslakes)
polypath(taslakes, col = "grey")
inlandwaters
library(rearcut)
library(rearcut)
plot(taslakes, pch = ".)
lines(na.omit(taslakes))
plot(taslakes, pch = ".")
lines(na.omit(taslakes))
polypath(taslakes, col = "grey")
nas <- which(is.na(taslakes$x_))
## this is the "indicate where holes start" convention
hole_index <- nas - seq_along(nas)
hole_index
ind <- earcut(minpoly)
ind <- earcut(na.omit(minpoly))
rearcut:::plot_tri(na.omit(minpoly), ind)
ind
rnage(ind)
range(in)
range(ind)
dim(na.omit(minpoly))
rearcut:::plot_tri(na.omit(minpoly)$x_, na.omit(minpoly)$y_, ind)
hole_index <- nas - seq_along(nas)
minpoly_xy <- na.omit(minpoly)
tri_index <- earcut(minpoly_xy, hole_index)
minpoly_xy
earcut
devtools::load_all(".")
earcut.default
xy.coords(minpoly_xy)
hole_index
plot(minpoly)
polypath(minpoly, col = "grey", rule = "evenodd")
lines(na.omit(minpoly))  ## see the connection in the sequence
nas <- which(is.na(minpoly$x_))
## this is the "indicate where holes start" convention
hole_index <- nas - seq_along(nas)
minpoly_xy <- na.omit(minpoly)
tri_index <- earcut(minpoly_xy, hole_index)
rearcut:::plot_tri(minpoly_xy$x_, minpoly_xy$y, ind)
rearcut:::plot_tri(minpoly_xy$x_, minpoly_xy$y_, ind)
tasnas <- which(is.na(taslakes$x_))
## this is the "indicate where holes start" convention
hole_index <- tasnas - seq_along(tasnas)
taslakes_xy <- na.omit(taslakes)
tri_index <- earcut(taslakes_xy, hole_index)
rearcut:::plot_tri(taslakes_xy$x_, taslakes_xy$y_, ind)
rearcut:::plot_tri(taslakes_xy$x_, taslakes_xy$y_, tri_index)
devtools::load_all(".")
example(minpoly)
library(rearcut)
example(minpoly)
example(taslakes)
plot_tri
rearcut:::plot_tri
?taslakes
taslakes
usethis::use_depsy()
usethis::use_depsy_badge()
library(rearcut)
pkgdown::build_site()
library(rearcut)
devtools::run_examples()
rearcut::plot_tri(taslakes_xy$x_, taslakes_xy$y_, tri_index, col = "grey")
plot(taslakes_xy)
dim(taslakes)
dim(taslakes_xy)
length(tri_index)
length(tri_index)/3
hole_index <- tasnas - (seq_along(tasnas)-1)
taslakes_xy <- na.omit(taslakes)
tri_index <- earcut(taslakes_xy, hole_index)
rearcut:::plot_tri(taslakes_xy$x_, taslakes_xy$y_, tri_index)
rearcut::plot_tri(taslakes_xy$x_, taslakes_xy$y_, tri_index, col = "grey")
rearcut:::plot_tri(minpoly_xy$x_, minpoly_xy$y_, tri_index, col = "firebrick")
library(rearcut)
examples(taslakes)
example(taslakes)
rearcut:::plot_tri(taslakes_xy$x_, taslakes_xy$y_, tri_index, col = "grey")
example(minpoly)
?taslakes
library(rearcut)
usethis::use_data(taslakes)
library(ggplot2)
taslakes[tri_index, ] %>% mutate(g = row_number() %/% 3)
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 )
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_, col = g)) + geom_polygon()
head(tri_index)
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_, col = g, group = g)) + geom_polygon()
plot(taslakes, pch = ".")
lines(na.omit(taslakes))
polypath(taslakes, col = "grey")
tasnas <- which(is.na(taslakes$x_))
## this is the "indicate where holes start" convention
hole_index <- tasnas - (seq_along(tasnas)-1)
taslakes_xy <- na.omit(taslakes)
tri_index <- earcut(taslakes_xy, hole_index)
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_, col = g, group = g)) + geom_polygon()
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_, fill = g, group = g)) + geom_polygon()
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 )
taslakes[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% tail()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_, fill = g, group = g)) + geom_polygon()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_,  group = g)) + geom_polygon()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_,  group = g, fill = NA)) + geom_polygon()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_,  group = g, fill = "")) + geom_polygon()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_,  group = g, fill = NULL)) + geom_polygon()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_,  group = g, fill = "transparent")) + geom_polygon()
taslakes_xy[tri_index, ] %>% mutate(g = (row_number() -1) %/% 3 ) %>% group_by(g) %>% ggplot(aes(x_, y_,  group = g)) + geom_path()
usethis::use_test("bad inputs")
earcut(1, 1)
library(rearcut)
earcut(1, 1)
library(testhat)
library(testthat)
expect_error(earcut(1, 1))
earcut(1, 1)
earcut(1:5, 1:3)
earcut(1:4, c(1, NA, 2:4))
xy.coords(1:4, 1:3)
devtools::load_all(".")
earcut.default(1:5, 1:3)
devtools::load_all(".")
expect_error(earcut(1, 1))
earcut(1, 1)
library(rearcut)
devtools::load_all(".")
earcut(1, 1)
earcut(1:5, 1:3)
x <- 1:5
if (length(x) < 3) stop("need at least  3 coordinates")
xy <- tibble::as_tibble(x)
xy
if (!ncol(xy) == 2L) stop("need x and y coordinates in 'x'")
library(rearcut)
expect_error(earcut(1, 1), "need at least 3 coordinates")
devtools::load_all(".")
expect_error(earcut(1, 1), "need at least 3 coordinates")
earcut(1:5, 1:3)
expect_error(earcut(1:5, 1:3), "need x and y coordinates in 'x'")
expect_error(earcut(1:4, c(1, NA, 2:4)))
earcut(1:4, c(1, NA, 2:4))
expect_error(earcut(cbind(1:4, c(1, NA, 2:4))))
earcut(cbind(1:4, c(1, NA, 2:4)))
devtools::load_all(".")
earcut(cbind(1:4, c(1, NA, 2:4)))
expect_error(earcut(cbind(1:4, c(1, NA, 3:4))))
expect_error(earcut(1:5, 1:3), "need x and y coordinates in x")
devtools::load_all(".")
expect_error(earcut(1:5, 1:3), "need x and y coordinates in x")
expect_error(earcut(1:5, 1:3), "need x and y coordinates in 'x'")
expect_error(earcut(cbind(1:4, c(1, NA, 3:4))), "missing values in y")
earcut(cbind(1:4, c(1, NA, 3:4)))
## (here the hole starts at 5 and is the only one)
x <- c(.1, .1, .9, .9, .2, .2, .8, .8)
y <- c(.1, .9, .9, .1, .2, .8, .8, .2)
ind2 <- earcut(list(x = x, y = y))
ind2 <- earcut(list(x = x, y = y))
library(rearcut)
x <- list(x = x, y = y)
unlist(x)
xy <- tibble::as_tibble(x)
xy
ind2 <- earcut(list(x = x, y = y))
## (here the hole starts at 5 and is the only one)
x <- c(.1, .1, .9, .9, .2, .2, .8, .8)
y <- c(.1, .9, .9, .1, .2, .8, .8, .2)
ind <- earcut(cbind(x, y), holes = 5L)
expect_equal(ind, c(1L, 5L, 6L, 8L, 5L, 1L, 2L, 1L, 6L, 8L, 1L, 4L, 3L, 2L, 6L,
7L, 8L, 4L, 3L, 6L, 7L, 7L, 4L, 3L))
expect_silent(rearcut:::plot_tri(x, y, ind, col = "grey"))
context("test with no holes")
ind2 <- earcut(list(x = x, y = y))
expect_equal(ind2, c(2L, 1L, 8L, 8L, 7L, 6L, 6L, 5L, 4L, 4L, 3L, 2L, 2L, 8L, 6L))
expect_error(earcut(1, 1), "need at least 3 coordinates")
expect_error(earcut(1:5, 1:3), "need x and y coordinates in 'x'")
expect_error(earcut(1:5, 1:6), "need x and y coordinates in 'x'")
earcut(1:5, 1:6)
expect_error(earcut(list(x = 1:5, y = 1:6)), "need x and y coordinates in 'x'")
earcut(list(x = 1:5, y = 1:6))
expect_error(earcut(list(x = 1:5, y = 1:6)), "Column `x` must be length 1 or 6, not 5")
expect_error(earcut(cbind(1:4, c(1, NA, 3:4))), "missing values in y")
usethis::use_package("tibble")
